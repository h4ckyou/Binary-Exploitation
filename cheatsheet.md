### CheatSheet For Binary Exploitation

To debug a binary on gdb-gef

```
gdb -q ./bofme --> runs the binary and supress the output

info functions --> lists functions in the binary

break main --> sets a breakpoint in main

nexti --> will have you go instruction by intruction through the program, but will not step into function calls such as puts

next --> which will take you through one line of code, but will step over function calls such as puts

step --> which will take you through one line of code, but will step into function calls

stepi --> whch will take you through one instruction at a time, stepping into function calls

disassemble --> disassembles a function when specified

info breakpoint --> shows the list of breakpoint set

delete <num> --> deletes a breakpoint where <num> is the breakpoint number

p $eip --> prints the address for eip register

info registers --> shows all the content of the registers

info frame --> shows the stack frame

set {char [12]} 0x080484b0 = "pwner" --> this sets the address specified to the value pwner

set *0x08048451 = 0xdeadbeef --> sets the address specified to 0xdeadbeef

j *0x08048451 --> this directly jumps to the memory address

search-pattern <string> --> search for a particular string in the stack
```

Working with a stripped binary using gdb

```
set disassembly-flavor intel --> sets the disassembly flavour to intel
info file --> list the content of the file #from this we can get the entry func
break __libc_start_main
```

Using pwntool

Pwntools Docs [Docs](http://docs.pwntools.com/en/stable/)

```
from pwn import * --> import it in python

target = remote("127.0.0.1", 9000) --> makes a connection to localhost on port 9000

target = process("./challenge") --> starts a binary called challenge

gdb.attach(target) --> attaches gdb debugger to a process

gdb.attach(target, gdbscript='b *main') -->  attaches the gdb debugger to a process, and also immediately pass a command to gdb to set a breakpoint at main

target.send(x) --> sends the variable x to the target (target can be something like a process, or remote connection established by pwntools)

target.sendline(x) --> send the variable x followed by a newline character appended to the end

print(target.recvline()) --> print a single line of text from target

print(target.recvuntil("out")) --> print all text from target up to the string out

p64(x) --> pack the integer x as a least endian QWORD (commonly used for x64)

p32(x) --> To pack the integer x as a least endian DWORD (commonly used for x86)

u64(x) --> It can also unpack values we get. Let's say we wanted to unpack a least endian QWORD and get it's integer value

u32(x) --> To unpack a DWORD

target.interactive() --> directly interact with target
```

Assembly 

```
### Registers

rbp: Base Pointer, points to the bottom of the current stack frame
rsp: Stack Pointer, points to the top of the current stack frame
rip: Instruction Pointer, points to the instruction to be executed

General Purpose Registers
These can be used for a variety of different things.
rax:
rbx:
rcx:
rdx:
rsi:
rdi:
r8:
r9:
r10:
r11:
r12:
r13:
r14:
r15:

x64 linux arguments to a function are passed in via registers.
rdi:    First Argument
rsi:    Second Argument
rdx:    Third Argument
rcx:    Fourth Argument
r8:     Fifth Argument
r9:     Sixth Argument

x86 elf architecture, arguments are passed onto the stack

+-----------------+---------------+---------------+------------+
| 8 Byte Register | Lower 4 Bytes | Lower 2 Bytes | Lower Byte |
+-----------------+---------------+---------------+------------+
|   rbp           |     ebp       |     bp        |     bpl    |
|   rsp           |     esp       |     sp        |     spl    |
|   rip           |     eip       |               |            |
|   rax           |     eax       |     ax        |     al     |
|   rbx           |     ebx       |     bx        |     bl     |
|   rcx           |     ecx       |     cx        |     cl     |
|   rdx           |     edx       |     dx        |     dl     |
|   rsi           |     esi       |     si        |     sil    |
|   rdi           |     edi       |     di        |     dil    |
|   r8            |     r8d       |     r8w       |     r8b    |
|   r9            |     r9d       |     r9w       |     r9b    |
|   r10           |     r10d      |     r10w      |     r10b   |
|   r11           |     r11d      |     r11w      |     r11b   |
|   r12           |     r12d      |     r12w      |     r12b   |
|   r13           |     r13d      |     r13w      |     r13b   |
|   r14           |     r14d      |     r14w      |     r14b   |
|   r15           |     r15d      |     r15w      |     r15b   |
+-----------------+---------------+---------------+------------+

### Flags

00:     Carry Flag
01:     always 1
02:     Parity Flag
03:     always 0
04:     Adjust Flag
05:     always 0
06:     Zero Flag
07:     Sign Flag
08:     Trap Flag
09:     Interruption Flag
10:     Direction Flag
11:     Overflow Flag
12:     I/O Privilege Field lower bit
13:     I/O Privilege Field higher bit
14:     Nested Task Flag
15:     Resume Flag

### Instructions

# mov
The move instruction just moves data from one register to another. For instance:
`mov rax, rdx`

This will just move the data from the rdx register to the rax register. Note that the data is moved into the first argument, not the second.

# dereference
If you ever see brackets like [], they are meant to dereference, which deals with pointers. A pointer is a value that points to a particular memory address (it is a memory address). Dereferencing a pointer means to treat a pointer like the value it points to. Put another way, a pointer is a variable that holds a memory address, and to dereference that pointer means you are accessing the value stored at that memory address. For instance:

`mov rax, [rdx]`
Will move the value pointed to by rdx into the rax register. On the flipside:

`mov [rax], rdx`
Will move the value of the rdx register into whatever memory is pointed to by the rax register. The actual value of the rax register does not change.

# lea
The lea instruction calculates the address of the second operand, and moves that address in the first. For instance:

`lea rdi, [rbx+0x10]`
This will move the address rbx+0x10 into the rdi register.

# add
This just adds the two values together, and stores the sum in the first argument. For instance:

`add rax, rdx`
That will add the value of rdx to rax, setting rax equal to rax + rdx.

# sub
This value will subtract the second operand from the first one, and store the difference in the first argument. For instance:

`sub rsp, 0x10`
This will subract 10 from rsp, setting the rsp register equal to rsp - 0x10

# xor
This will perform the binary operation xor on the two arguments it is given, and stores the result in the first argument:

`xor rdx, rax`
This will set the rdx register equal to rdx ^ rax. If the xor instruction is used with the same register for both argument, for example xor rax, rax, it will set all bits to zero, clearing the register.

To understand how xor works, you must understand that it is a bitwise operation, meaning it operates on the bits of a register. It compares the bits in each place, and sets the resulting bit to 1 if the bits are different, and 0 if they are the same. So for example, xor 1011 1100 would return 0111.

The and and or instructions essentially do the same thing, except with the AND or OR binary operators. For and it sets the resulting bit to 1 if both bits are also 1, otherwise it sets it to 0. For or it sets the resulting bit to 1 if either bit is 1, otherwise it is set to 0.

# push
The push instruction will grow the stack by either 8 bytes (for x64, 4 for x86), then push the contents of a register onto the new stack space. For instance:

``push rax`
This will grow the stack by 8 bytes, and the contents of the rax register will be on top of the stack.

# pop
The pop instruction will pop the top 8 bytes (for x64, 4 for x86) off of the stack and into the argument. Then it will shrink the stack. For instance:

`pop rax`
The top 8 bytes of the stack will end up in the rax register.

# jmp
The jmp instruction will jump to an instruction address. It is used to redirect code execution. For instance:

`jmp 0x602010`
That instruction will cause the code execution to jump to 0x602010, and execute whatever instruction is there.

# call & ret
This is similar to the jmp instruction. The difference is it will push the values of rbp and rip onto the stack, then jump to whatever address it is given. This is used for calling functions. After the function is finished, a ret instruction is called which uses the pushed values of rbp and rip (saved base and instruction pointers) to return, it can continue execution right where it left off.

# cmp
The cmp instruction is similar to that of the sub instruction. Except it doesn't store the result in the first argument. It checks if the result is less than zero, greater than zero, or equal to zero. Depending on the value it will set the flags accordingly.

# jnz / jz
The jump if not zero and jump if zero (jnz/jz) instructions are pretty similar to the jump instruction. The difference is they will only execute the jump depending on the status of the zero flag. For jz it will only jump if the zero flag is set. The opposite is true for jnz. These instructions are how control flow is implemented in assembly.
```
