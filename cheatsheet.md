### CheatSheet For Binary Exploitation

To debug a binary on gdb-gef

```
gdb -q ./bofme --> runs the binary and supress the output

info functions --> lists functions in the binary

break main --> sets a breakpoint in main

nexti --> will have you go instruction by intruction through the program, but will not step into function calls such as puts

next --> which will take you through one line of code, but will step over function calls such as puts

step --> which will take you through one line of code, but will step into function calls

stepi --> whch will take you through one instruction at a time, stepping into function calls

disassemble --> disassembles a function when specified

info breakpoint --> shows the list of breakpoint set

delete <num> --> deletes a breakpoint where <num> is the breakpoint number

p $eip --> prints the address for eip register

info registers --> shows all the content of the registers

info frame --> shows the stack frame

set {char [12]} 0x080484b0 = "pwner" --> this sets the address specified to the value pwner

set *0x08048451 = 0xdeadbeef --> sets the address specified to 0xdeadbeef

j *0x08048451 --> this directly jumps to the memory address
```

Working with a stripped binary using gdb

```
set disassembly-flavor intel --> sets the disassembly flavour to intel
info file --> list the content of the file #from this we can get the entry func
break __libc_start_main
```

Using pwntool

Pwntools Docs [Docs](http://docs.pwntools.com/en/stable/)

```
from pwn import * --> import it in python

target = remote("127.0.0.1", 9000) --> makes a connection to localhost on port 9000

target = process("./challenge") --> starts a binary called challenge

gdb.attach(target) --> attaches gdb debugger to a process

gdb.attach(target, gdbscript='b *main') -->  attaches the gdb debugger to a process, and also immediately pass a command to gdb to set a breakpoint at main

target.send(x) --> sends the variable x to the target (target can be something like a process, or remote connection established by pwntools)

target.sendline(x) --> send the variable x followed by a newline character appended to the end

print(target.recvline()) --> print a single line of text from target

print(target.recvuntil("out")) --> print all text from target up to the string out

p64(x) --> pack the integer x as a least endian QWORD (commonly used for x64)

p32(x) --> To pack the integer x as a least endian DWORD (commonly used for x86)

u64(x) --> It can also unpack values we get. Let's say we wanted to unpack a least endian QWORD and get it's integer value

u32(x) --> To unpack a DWORD

target.interactive() --> directly interact with target
```



