<h2> ROP Emporium </h2>

    - Challenge 1
    - Chall Name: ret2win

![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/29954433-c439-4cc9-a4c0-ebb5a6fdebdc)

This is the beginning of the ROP Emporium series and I'll be dealing with just the x64 architecture for now.

##### File Checks:-

First thing first is always knowing what type of file you are working with and the protections enabled on it.
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/98a9cbaa-e552-46b3-98a6-47f44bb0628e)

Cool we are dealing with a 64 bits executable which is dynamically linked and not stripped.

What does it mean for a binary to be dynamically linked? I can't explain that here but feel free to read [this](https://www.baeldung.com/cs/static-dynamic-linking-differences)

The result from running **checksec** gives this:
- Arch:     amd64-64-little
- RELRO:    Partial RELRO
- Stack:    No canary found
- NX:       NX enabled
- PIE:      No PIE (0x400000)

Here are what each protection does:
- **RELRO (Relocation Read-Only)** when enabled to be **FULL** basically makes the **GOT** read only so that would make **GOT** overwrite not possible but in this case it's **PARTIAL** which makes **GOT** overwrite possible.
- **Stack** in this case shows that there are no canaries which makes exploiting buffer overflow possible but if they were canary enabled we would need to find a way to leak it as it would make exploiting a  buffer overflow hard.
- **NX (No Execute)** in this case shows that it's enabled which means we can't put shellcode on the stack and execute it.
- **PIE (Position Independent Executable)** in this case is not enabled which makes the binary memory address the same on each execution.

Now that we know that let's run the binary to get an overview of what it does
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/debb5112-c641-485c-86bc-67409924c5fe)

It would receive our input then exit.

One thing to note there is the text printed to stdout when running the binary:

```
For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
```

If that isn't bluffing then we have a buffer overflow vulnerability






















