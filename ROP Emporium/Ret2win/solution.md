<h2> ROP Emporium </h2>

    - Challenge 1
    - Chall Name: ret2win

![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/29954433-c439-4cc9-a4c0-ebb5a6fdebdc)

This is the beginning of the ROP Emporium series and I'll be dealing with just the x64 architecture for now.

##### File Checks:-

First thing first is always knowing what type of file you are working with and the protections enabled on it.
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/98a9cbaa-e552-46b3-98a6-47f44bb0628e)

Cool we are dealing with a 64 bits executable which is dynamically linked and not stripped.

What does it mean for a binary to be dynamically linked? I can't explain that here but feel free to read [this](https://www.baeldung.com/cs/static-dynamic-linking-differences)

The result from running **checksec** gives this:
- Arch:     amd64-64-little
- RELRO:    Partial RELRO
- Stack:    No canary found
- NX:       NX enabled
- PIE:      No PIE (0x400000)

Here are what each protection does:
- **RELRO (Relocation Read-Only)** when enabled to be **FULL** basically makes the **GOT** read only so that would make **GOT** overwrite not possible but in this case it's **PARTIAL** which makes **GOT** overwrite possible.
- **Stack** in this case shows that there are no canaries which makes exploiting buffer overflow possible but if they were canary enabled we would need to find a way to leak it as it would make exploiting a  buffer overflow hard.
- **NX (No Execute)** in this case shows that it's enabled which means we can't put shellcode on the stack and execute it.
- **PIE (Position Independent Executable)** in this case is not enabled which makes the binary memory address the same on each execution.

Now that we know that let's run the binary to get an overview of what it does
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/debb5112-c641-485c-86bc-67409924c5fe)

It would receive our input then exit.

One thing to note there is the text printed to stdout when running the binary:

```
For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
```

If that isn't bluffing then we have a buffer overflow vulnerability but let us confirm it by decompiling it in Ghidra and viewing the function that works with our input

Here's the main function
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/7370a86a-33ba-4352-b668-60a07a943185)

Nothing really interesting there except that it calls the `pwnme()` function, here's the decompilation for that function
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/aa842466-7388-4c89-9457-86e663b4409f)

So it defines a buffer that can hold up just 32 bytes but then reads in at most 56 bytes to that buffer

This means the text wasn't bluff hehe so we have a buffer overflow here

Looking through the available functions I found a function that isn't called by `main() or pwnme()` but tends to read the flag file content
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/7defc740-7bb1-4418-93a4-2a2ef7484a33)

Our goal is to call this function

Let us get the offset needed to overwrite the instruction pointer
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/387876e3-c458-4359-a1e9-fe3204bcf46a)
![image](https://github.com/h4ckyou/Binary-Exploitation/assets/127159644/4356cb8d-beb5-49ca-9959-d8ef4bd19a69)

So the offset is 40

The payload would be to send `junk + ret2win()`

But one thing that would cause an issue is movaps stack allignment 

If you're segfaulting on a movaps instruction in **buffered_vfprintf()** or **do_system()** in the x86_64 challenges, then ensure the stack is 16-byte aligned before returning to GLIBC functions such as **printf()** or **system()**. Some versions of GLIBC uses movaps instructions to move data onto the stack in certain functions. The 64 bit calling convention requires the stack to be 16-byte aligned before a call instruction but this is easily violated during ROP chain execution, causing all further calls from that function to be made with a misaligned stack. movaps triggers a general protection fault when operating on unaligned data, so try padding your ROP chain with an extra ret before returning into a function or return further into a function to skip a push instruction

To prevent this I added a `ret` instruction before calling the `ret2win` function















































